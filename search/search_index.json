{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What is band structure","text":"<p>To a first-order approximation, one could say that computational material science is essentially the prediction of material behavior. For example, we might wish to see if some arrangement of atoms forms a semiconductor or a metal, or to go further and compute the thermal and electrical conductivity of the material. Here, we focus on crystalline solids where we may assume the atoms are arranged periodically. The properties of materials are largely determined by the behavior of the electrons under the potential landscape created by this arrangement. </p> <p>Solving for electron behavior in an isolated atom yields the familiar \\(s\\), \\(p\\), \\(d\\), \\(\\ldots\\), orbitals we get from solving the Schr\u00f6dinger equation in spherical coordinates. However, a material contains many atoms, resulting in a periodic potential. Electrons now display complex \\textit{interatomic} behavior, with linear combinations of bonding and antibonding states. This drastically changes the energy landscape: single-atom electron orbitals have neatly-spaced discrete energies, but electrons in a many-atom system have orbitals that hybridize and combine, yielding a continuous spectrum of allowed energies around the single-atom energies. These solutions are numerous enough to form a continuous band in reciprocal space, and the result is what is known as a band structure.  </p> <p>Out interest is in solving the energy states of the schrodinger equation under a periodic potential such that \\(V(\\br)=V(\\br+\\bR)\\). The following tutorial will provide an introduction into how to think about the </p> <ul> <li>1D examples</li> <li>Band structure tutorial</li> </ul>"},{"location":"1D-full%20solution/","title":"1D full solution","text":"<p>We seek the wavefunction \\(\\psi\\) to the schrodinger equation however we do not know what it looks like. We do know that we can represent it as a sum over some othonormal basis functions denoted as \\(\\phi_i\\)</p> \\[ \\psi = \\sum _i^{n}c_i\\phi_i \\] <p>The full wavefunction is optained once we have our coefficients \\(c_i\\)</p> <p>Our goal is to solve the s.e. \\(H\\psi=E\\psi\\). We can express this in terms of our basis functions </p> \\[ \\hat{H}\\sum_i^{\\infty}c_i\\phi_j=E\\sum_i^{\\infty}c_i\\phi_i\\] <p>given that we chose orthonormal basis functions, we can multiply by \\(\\phi_i*\\) and integrate </p> \\[ \\hat{H}\\sum_i^{\\infty}c_i\\phi_j=E\\sum_i^{\\infty}c_i\\phi_i\\] <p>resulting in </p> \\[\\sum_i^{\\infty}H_{mn}c_n=Ec_m\\] <p>We can convert this to a matrix equation </p> \\[H_{ij}=\\int\\phi_i\\hat{H}\\phi_j dx\\] <p>Our hamiltonian matrix is thus </p> \\[ \\tilde{H} = \\begin{bmatrix} H_{11} &amp; H_{12} &amp; \\cdots &amp; H_{1N} \\\\ H_{21} &amp; H_{22} &amp; \\cdots &amp; H_{2N} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ H_{N1} &amp; H_{N2} &amp; \\cdots &amp; H_{NN} \\end{bmatrix} \\] <p>then our wavefunction \\(\\psi\\) </p> <pre><code>&lt;svg id=\"plot\" viewBox=\"0 0 800 500\" preserveAspectRatio=\"xMidYMid meet\" style=\"width: 100%; height: 500px;\"&gt;&lt;/svg&gt;\n&lt;div id=\"plot-container\" style=\"width: 100%; max-width: 900px; height: auto; margin: auto; position: relative;\"&gt;\n&lt;svg id=\"plot\" viewBox=\"0 0 800 500\" preserveAspectRatio=\"xMidYMid meet\" style=\"width: 100%; height: auto;\"&gt;&lt;/svg&gt;\n</code></pre> <pre><code>&lt;script&gt;\n    function updateLabel(labelId, value) {\n        document.getElementById(labelId).textContent = value;\n    }\n\n    async function updatePlot() {\n        let nWells = document.getElementById(\"nWells\").value;\n        let bHeight = document.getElementById(\"bHeight\").value;\n        let bWidth = parseFloat(document.getElementById(\"bWidth\").value).toFixed(1);\n        let key = `${nWells}_wells_${bHeight}_depth`;\n\n        let jsonPath = window.location.origin + \"/wavefunctions.json\"; // Ensure correct file path\n        console.log(\"Fetching JSON from:\", jsonPath, \"with key:\", key);\n\n        try {\n            let response = await fetch(jsonPath);\n            if (!response.ok) {\n                throw new Error(`HTTP error! Status: ${response.status}`);\n            }\n\n            let data_store = await response.json();\n\n            if (!(key in data_store)) {\n                console.error(\"No precomputed data for this parameter set:\", key);\n                return;\n            }\n\n            let data = data_store[key];\n            let x_vals = data.x_vals;\n            let potential = data.potential;\n            let wavefunctions = data.wavefunctions;\n            let eigenvalues = data.eigenvalues;\n\n            if (!x_vals.length || !wavefunctions.length || !eigenvalues.length) {\n                console.error(\"Data arrays are empty. Cannot plot.\");\n                return;\n            }\n\n            let svg = d3.select(\"#plot\"),\n                width = +svg.attr(\"width\"),\n                height = +svg.attr(\"height\");\n\n            let margin = { top: 20, right: 20, bottom: 50, left: 50 };\n            let plotWidth = width - margin.left - margin.right;\n            let plotHeight = height - margin.top - margin.bottom;\n\n            let xScale = d3.scaleLinear()\n                .domain([Math.min(...x_vals), Math.max(...x_vals)])\n                .range([margin.left, plotWidth]);\n\n            let yScale = d3.scaleLinear()\n                .domain([\n                    Math.min(...potential, ...eigenvalues) - 5,\n                    Math.max(...potential, ...eigenvalues) + 5\n                ])\n                .range([plotHeight, margin.top]);\n\n            svg.selectAll(\"*\").remove();\n\n            svg.append(\"path\")\n                .datum(x_vals.map((x, i) =&gt; ({ x: x, y: potential[i] })))\n                .attr(\"fill\", \"none\")\n                .attr(\"stroke\", \"green\")\n                .attr(\"stroke-width\", 2)\n                .attr(\"d\", d3.line().x(d =&gt; xScale(d.x)).y(d =&gt; yScale(d.y)));\n\n            wavefunctions.forEach((wave, i) =&gt; {\n                svg.append(\"path\")\n                    .datum(x_vals.map((x, j) =&gt; ({ x: x, y: wave[j] * 5 + eigenvalues[i] })))\n                    .attr(\"fill\", \"none\")\n                    .attr(\"stroke\", d3.schemeCategory10[i % 10])\n                    .attr(\"stroke-width\", 1.5)\n                    .attr(\"d\", d3.line().x(d =&gt; xScale(d.x)).y(d =&gt; yScale(d.y)));\n            });\n\n            svg.append(\"g\")\n                .attr(\"transform\", `translate(0, ${plotHeight})`)\n                .call(d3.axisBottom(xScale));\n\n            svg.append(\"g\")\n                .attr(\"transform\", `translate(${margin.left}, 0)`)\n                .call(d3.axisLeft(yScale));\n\n        } catch (error) {\n            console.error(\"Error loading JSON:\", error);\n        }\n    }\n\n    updatePlot();\n&lt;/script&gt;\n</code></pre> <p>  --&gt;</p>"},{"location":"1Dfinite/","title":"1D example","text":"<p>To understand material properties, we need to study how electrons move in solids. While classical mechanics gave us some insight into how electrons move, certain properties, such as heat capcaity, etc can not be propoerly descirbed without quantum mechanics. The Schr\u00f6dinger equation describes the quantum behavior of an electron in a given potential. However, solving the Schr\u00f6dinger equation for a solid, where multiple periodic potentials, is extremely challenging. This tutorial introduces the concept of band structure\u2014the energy eigenstates of electrons in a periodic potential.</p>"},{"location":"1Dfinite/#finite-square-well","title":"Finite square well","text":"<p>Before tackling the Schr\u00f6dinger equation in a system with multiple potentials, it's important to first understand its solutions for a single, isolated potential. Suppose we make a huge simplification and assume the potential an electron feels due to the nucleus is given by a 1D square well potential. </p> <p>We are interested in solving the  1D time independent schrodinger equation</p> \\[ \\left[ -\\frac{\\hbar^2}{2m} \\frac{d^2}{dx^2} + V(x) \\right] \\Psi(x) = E \\Psi(x) \\] <p>subject to a simple finite square well potential </p> \\[ V(x) = \\begin{cases}  0, &amp; x &lt; -a \\\\  -V_0, &amp; -a \\leq x \\leq a\\\\ 0, &amp; x &gt; a  \\\\  \\end{cases} \\] <p>The solutions can be either bound states, (\\(E&lt;0\\)) or scattering states \\(E&gt;0\\). Both are important for understanding electronic behavior. For simplicity, we we start by describing the bound state solutions. </p> \\[ \\Psi(x) = \\begin{cases}  A e^{\\kappa x}, &amp; x &lt; -a \\\\  B \\cos(k x) + C \\sin(k x), &amp; -a \\leq x \\leq a \\\\  D e^{-\\kappa x}, &amp; x &gt; a \\end{cases} \\] <p>where \\(\\kappa\\) and \\(k\\) are</p> \\[ \\kappa = \\sqrt{\\frac{2m |E|}{\\hbar^2}} \\] \\[ k = \\sqrt{\\frac{2m (V_0 + E)}{\\hbar^2}} \\] <p>To find the allowed energy levels, we must enforce  continuity of \\(\\psi(x)\\) and \\(\\psi'(x)\\) at \\(x=-a\\) and \\(x=a\\)</p> <p>Due to the symmetry of the problem, we realize the solutions inside the well are either even or odd. We enforce the boundary conditions for each one respectively. This results in the following transidental equations </p> <p>for even states</p> \\[ \\kappa = k\\tan(ka) \\] <p>for odd states </p> \\[ \\kappa = -k\\cot(ka) \\] V0: 30 a/2: 1 Eigenvalues from Intersection:"},{"location":"1Dfinite/#two-square-wells","title":"Two square wells","text":"<p>Our final goal is to understand electronic behavior in solids. We take our previous example one step closer by considering the behavior of a single electron in the potential induced by two nuclei spaced apart by a distannce \\(a\\). This is essentially the \\(H_2\\) molecule, but we follow with the simplification that the \\(H_2\\) atom </p>"},{"location":"bands/","title":"Introduction to bands","text":""},{"location":"bands/#free-particle-solution","title":"Free particle solution","text":""},{"location":"bands/#blochs-theorem","title":"Bloch's theorem","text":"<p>Our lattice is periodic under translation by a lattice vector \\(\\bR\\). While it is not immediately clear how this will play into our final solution, it is helpful to start by introducing a translation operator \\(\\That\\) such that </p> \\[     \\That \\psi(\\br)=\\psi(\\br+\\bR) \\] <p>The eigenspectrum of this operator seems a little easier to understand than that of \\(\\Hhat\\). Because our lattice is periodic in \\(\\bR\\), implying \\(\\Hhat(\\br + \\bR) = \\Hhat(\\br)\\), we can show that the operators \\(\\That\\) and \\(\\Hhat\\) commute:</p> \\[     \\That\\Hhat(\\br)\\psi(\\br) = \\Hhat(\\br + \\bR)\\psi(\\br + \\bR) = \\Hhat(\\br)\\That\\psi(\\br) \\] <p>By a well-known property, showing that \\(\\That\\) and \\(\\Hhat\\) commute under periodicity \\(\\bR\\) implies that they share a common set of eigenfunctions. Finding the eigenfunctions of \\(\\That\\) then equates to solving for the eigenfunctions of \\(\\Hhat\\), a powerful simplification.</p> <p>We now wish to determine the form of the eigenfunctions of \\(\\That\\). For example, eigenfunctions of eigenvalue \\(\\lambda=1\\) are totally periodic in \\(\\bR\\), such that \\(f(\\br)\\)  does not change when translated by \\(\\bR\\):</p> \\[ \\That f(\\br)=f(\\br+\\bR)=f(\\br) \\] <p>More generally, consider a function that is not trivially periodic but  satisfies \\(\\psi(\\br+\\bR)=\\lambda \\psi(\\br)\\). This behavior is well described by an exponential, but because we are describing a quantum system, it has to be an exponential that is normalizable, i.e., a complex exponential of the form \\(\\psi = e^{i\\bk\\cdot\\br}\\). We apply \\(\\That\\) to find its eigenvalue: </p> \\[    \\That e^{i\\bk\\cdot\\br} = e^{i(\\bk \\cdot \\br + \\bk \\cdot \\bR)} =  \\underbrace{e^{i \\bk \\cdot \\bR}}_{\\lambda} e^{i \\bk \\cdot \\br} \\] <p>Our final eigenstate \\(\\psi\\) can be either periodic or of the form of the complex exponential. In general, any eigenfunction of \\(\\That\\) can be written</p> \\[     \\psi(\\br)=e^{i\\bk \\cdot \\br}f(\\br) \\] <p>% where once again, \\(f(\\br) = f(\\br + \\bR)\\), and \\(e^{i\\bk \\cdot \\br}\\) is a consequence of the translational invariance of the system. As before, we can find the eigenvalue:</p> \\[     \\That \\psi(\\br) = e^{i \\bk \\cdot \\bR} e^{i \\bk \\cdot \\br} f(\\br+\\bR)=e^{i \\bk \\cdot \\bR} e^{i \\bk \\cdot \\br} f(\\br) \\] <p>Now we reiterate that the eigenfunction \\(\\psi\\) also belongs to \\(\\Hhat\\)---we've exploited the commutativity of the two operators to find a solution for our periodic system simply by considering \\(\\That\\). This is Bloch's theorem. These so-called \\textit{Bloch waves} can be written in full as</p> \\[ \\psi_{n\\bk}(\\br)=e^{i \\bk \\cdot \\br} f_{n\\bk}(\\br) \\]"}]}